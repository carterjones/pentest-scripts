package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/elazarl/goproxy"
)

type RequestHandler struct{}

func (rh *RequestHandler) Process(
	r *http.Request,
	ctx *goproxy.ProxyCtx,
	settings *Settings) (*http.Request, *http.Response, error) {
	if settings.DuplicateRequests {
		// Get a copy of the request data.
		data, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return nil, nil, err
		}

		// Perform the duplicate request.
		rh.PerformDuplicateRequest(r.Method, r.URL.String(), data, r.Header)

		// Prepare the request to be sent along the pipeline.
		r.Body = ioutil.NopCloser(bytes.NewReader(data))
	}

	if settings.LogRequests {
		if !settings.HostRex.MatchString(r.URL.Host) {
			return r, nil, nil
		}

		println("[" + r.Method + "] " + r.URL.Scheme + "://" + r.URL.Host + r.URL.Path)
		urlParams := r.URL.Query()
		for k, _ := range urlParams {
			println("  " + k + ":" + urlParams.Get(k))
		}

		if r.Method == "POST" {
			// Do things with r.Body here
			// data, err := ioutil.ReadAll(r.Body)
			// if err != nil {
			// 	return nil, nil, err
			// }
			// println(string(data))
			// r.Body = ioutil.NopCloser(bytes.NewReader(data))
		}
	}

	if settings.TestDecoding {
		// Test decoding cookies.
		cs := r.Cookies()
		for _, c := range cs {
			decoded, err := urlBase64Decode(c.Value)

			// Print results if an error is *not* encountered.
			if err == nil {
				fmt.Println("[+] (b64 encoded cookie) " + c.Name + ": " + string(decoded))
			}
		}

		// Test decoding headers.
		for name, headers := range r.Header {
			name = strings.ToLower(name)
			for _, h := range headers {
				decoded, err := urlBase64Decode(h)

				// Print results if an error is *not* encountered.
				if err == nil {
					fmt.Println("[+] (b64 encoded header) " + name + ": " + string(decoded))
				}
			}
		}
	}

	return r, nil, nil
}

func urlBase64Decode(s string) ([]byte, error) {
	urlDecoded, err := url.QueryUnescape(s)
	if err != nil {
		return []byte{}, err
	}

	b64Decoded, err := base64.StdEncoding.DecodeString(urlDecoded)
	if err != nil {
		return []byte{}, err
	}

	return b64Decoded, nil
}

func (rh *RequestHandler) PerformDuplicateRequest(method, urlStr string, body []byte, header http.Header) error {
	client := &http.Client{}
	bodyReader := ioutil.NopCloser(bytes.NewReader(body))

	req, err := http.NewRequest(method, urlStr, bodyReader)
	if err != nil {
		return err
	}

	// Add headers to request.
	for k, v := range header {
		req.Header.Add(k, strings.Join(v, ", "))
	}
	_, err = client.Do(req)

	if err != nil {
		return err
	}

	return nil
}

// func checkForDomXss() {
// 	// From https://code.google.com/archive/p/domxsswiki/wikis/FindingDOMXSS.wiki
// 	sources := `(location\s*[\[.])|([.\[]\s*["']?\s*(arguments|dialogArguments|innerHTML|write(ln)?|open(Dialog)?|showModalDialog|cookie|URL|documentURI|baseURI|referrer|name|opener|parent|top|content|self|frames)\W)|(localStorage|sessionStorage|Database)`
// 	sinks := `((src|href|data|location|code|value|action)\s*["'\]]*\s*\+?\s*=)|((replace|assign|navigate|getResponseHeader|open(Dialog)?|showModalDialog|eval|evaluate|execCommand|execScript|setTimeout|setInterval)\s*["'\]]*\s*\()`
// 	jquerySinks := `after\(|\.append\(|\.before\(|\.html\(|\.prepend\(|\.replaceWith\(|\.wrap\(|\.wrapAll\(|\$\(|\.globalEval\(|\.add\(|jQUery\(|\$\(|\.parseHTML\(`
// 	fmt.Println(sources, sinks, jquerySinks)
// }
